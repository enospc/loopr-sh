#!/usr/bin/env python3
"""
Detect greenfield vs existing and persist init-state for Loopr.
"""
from __future__ import annotations

import argparse
import json
import sys
from datetime import datetime, timezone
from fnmatch import fnmatch
from pathlib import Path


DEFAULT_ALLOW_FILES = [
    "readme*",
    "license*",
    "changelog*",
    "contributing*",
    "code_of_conduct*",
    "security*",
    "notice*",
    ".gitignore",
    ".gitattributes",
    ".editorconfig",
    "agents.md",
]

DEFAULT_ALLOW_DIRS = [
    ".git",
    ".github",
    ".vscode",
    "docs",
    "specs",
]


def normalize(name: str) -> str:
    return name.lower()


def is_allowed_file(name: str, allow_files: list[str]) -> bool:
    lname = normalize(name)
    return any(fnmatch(lname, pattern) for pattern in allow_files)


def is_allowed_dir(name: str, allow_dirs: list[str]) -> bool:
    return normalize(name) in allow_dirs


def scan_signals(root: Path, allow_files: list[str], allow_dirs: list[str]) -> list[str]:
    signals: list[str] = []
    for entry in root.iterdir():
        name = entry.name
        if entry.is_dir():
            if is_allowed_dir(name, allow_dirs):
                continue
            signals.append(f"{name}/")
        else:
            if is_allowed_file(name, allow_files):
                continue
            signals.append(name)
    return sorted(signals)


def main() -> int:
    parser = argparse.ArgumentParser(
        description="Detect greenfield vs existing and write specs/.loopr/init-state.json",
    )
    parser.add_argument(
        "--root",
        default=".",
        help="Repo root to scan (default: current directory)",
    )
    parser.add_argument(
        "--specs-dir",
        default="specs",
        help="Path to specs directory (default: specs)",
    )
    parser.add_argument(
        "--allow-existing",
        action="store_true",
        help="Permit initialization even if non-greenfield signals are present",
    )
    args = parser.parse_args()

    root = Path(args.root).resolve()
    specs_dir = root / args.specs_dir
    loopr_dir = specs_dir / ".loopr"
    init_state_path = loopr_dir / "init-state.json"
    repo_id_path = loopr_dir / "repo-id"
    decisions_dir = specs_dir / "decisions"
    decisions_template = decisions_dir / "template.md"

    template_body = "\n".join(
        [
            "# Title",
            "",
            "## Date",
            "",
            "## Status",
            "",
            "## Context",
            "",
            "## Decision",
            "",
            "## Alternatives",
            "",
            "## Consequences",
            "",
        ]
    )

    def ensure_decision_template() -> None:
        decisions_dir.mkdir(parents=True, exist_ok=True)
        if not decisions_template.exists():
            decisions_template.write_text(template_body)

    if init_state_path.exists():
        ensure_decision_template()
        print("INIT_STATE_EXISTS")
        return 0

    allow_files = [normalize(p) for p in DEFAULT_ALLOW_FILES]
    allow_dirs = [normalize(p) for p in DEFAULT_ALLOW_DIRS]
    signals = scan_signals(root, allow_files, allow_dirs)

    if repo_id_path.exists():
        mode = "existing"
    else:
        if signals and not args.allow_existing:
            print("NON_GREENFIELD_DETECTED", file=sys.stderr)
            for signal in signals:
                print(f"- {signal}", file=sys.stderr)
            return 1
        mode = "existing" if signals else "greenfield"

    loopr_dir.mkdir(parents=True, exist_ok=True)
    ensure_decision_template()
    state = {
        "mode": mode,
        "signals": signals,
        "initialized_at": datetime.now(timezone.utc).isoformat(),
    }
    init_state_path.write_text(json.dumps(state, indent=2, sort_keys=True) + "\n")

    print(f"INIT_STATE_WRITTEN {init_state_path}")
    print(f"mode={mode}")
    if signals:
        print("signals=" + ", ".join(signals))
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
