#!/usr/bin/env python3
"""
Validate Loopr order YAML files and their referenced artifacts.

Checks:
- feature-order.yaml, task-order.yaml, test-order.yaml schema sanity
- feature/task/test file existence based on order files
- consistent feature/task references across files
"""
from __future__ import annotations

import argparse
import json
import re
import sys
from pathlib import Path


try:
    import yaml  # type: ignore
except Exception:
    print(
        "Missing dependency: PyYAML. Install with `python3 -m pip install pyyaml`.",
        file=sys.stderr,
    )
    sys.exit(2)


ID_RE = re.compile(r"^[0-9]+$")


def main() -> int:
    parser = argparse.ArgumentParser(description="Validate Loopr order YAML files.")
    parser.add_argument(
        "--specs-dir",
        default="specs",
        help="Path to specs directory (default: specs)",
    )
    args = parser.parse_args()

    specs_dir = Path(args.specs_dir)
    errors: list[str] = []
    warnings: list[str] = []

    def err(msg: str) -> None:
        errors.append(msg)

    def warn(msg: str) -> None:
        warnings.append(msg)

    def load_yaml(path: Path):
        try:
            return yaml.safe_load(path.read_text())
        except Exception as exc:
            err(f"Failed to parse {path}: {exc}")
            return None

    feature_order_path = specs_dir / "feature-order.yaml"
    task_order_path = specs_dir / "task-order.yaml"
    test_order_path = specs_dir / "test-order.yaml"
    init_state_path = specs_dir / ".loopr" / "init-state.json"

    mode = "existing"
    if init_state_path.exists():
        try:
            init_state = json.loads(init_state_path.read_text())
        except Exception as exc:
            err(f"Failed to parse {init_state_path}: {exc}")
            init_state = None
        if isinstance(init_state, dict):
            state_mode = init_state.get("mode")
            if state_mode in {"greenfield", "existing"}:
                mode = state_mode
            else:
                err(
                    f"{init_state_path}: mode must be 'greenfield' or 'existing' (got {state_mode!r})"
                )
    else:
        warn(f"Missing {init_state_path}; assuming existing mode")

    if not feature_order_path.exists():
        err(f"Missing {feature_order_path}")
    if not task_order_path.exists():
        err(f"Missing {task_order_path}")
    if not test_order_path.exists():
        err(f"Missing {test_order_path}")

    feature_order = load_yaml(feature_order_path) if feature_order_path.exists() else None
    task_order = load_yaml(task_order_path) if task_order_path.exists() else None
    test_order = load_yaml(test_order_path) if test_order_path.exists() else None

    feature_slugs: list[str] = []
    feature_titles: dict[str, str] = {}

    if isinstance(feature_order, dict):
        features = feature_order.get("features")
        if not isinstance(features, list) or not features:
            err("feature-order.yaml: 'features' must be a non-empty list")
        else:
            seen = set()
            for idx, f in enumerate(features):
                if not isinstance(f, dict):
                    err(f"feature-order.yaml: feature[{idx}] must be a map")
                    continue
                slug = f.get("slug")
                title = f.get("title", "")
                if not isinstance(slug, str) or not slug:
                    err(f"feature-order.yaml: feature[{idx}].slug must be a string")
                    continue
                if slug in seen:
                    err(f"feature-order.yaml: duplicate feature slug '{slug}'")
                    continue
                seen.add(slug)
                feature_slugs.append(slug)
                if isinstance(title, str):
                    feature_titles[slug] = title
                depends_on = f.get("depends_on", [])
                if depends_on is None:
                    depends_on = []
                if not isinstance(depends_on, list) or any(
                    not isinstance(d, str) for d in depends_on
                ):
                    err(
                        f"feature-order.yaml: feature[{idx}].depends_on must be a list of strings"
                    )
            if mode == "greenfield" and feature_slugs and feature_slugs[0] != "foundation":
                err(
                    "feature-order.yaml: first feature must be 'foundation' when mode=greenfield"
                )
    elif feature_order is not None:
        err("feature-order.yaml: root must be a map")

    # Validate feature files exist.
    for slug in feature_slugs:
        fpath = specs_dir / f"feature-{slug}.md"
        if not fpath.exists():
            err(f"Missing feature file: {fpath}")

    expected_tasks: dict[str, list[str]] = {}

    if isinstance(task_order, dict):
        features = task_order.get("features")
        if not isinstance(features, list) or not features:
            err("task-order.yaml: 'features' must be a non-empty list")
        else:
            for idx, f in enumerate(features):
                if not isinstance(f, dict):
                    err(f"task-order.yaml: feature[{idx}] must be a map")
                    continue
                slug = f.get("slug")
                if not isinstance(slug, str) or not slug:
                    err(f"task-order.yaml: feature[{idx}].slug must be a string")
                    continue
                if feature_slugs and slug not in feature_slugs:
                    err(f"task-order.yaml: unknown feature slug '{slug}'")
                tasks = f.get("tasks")
                if not isinstance(tasks, list) or not tasks:
                    err(f"task-order.yaml: feature '{slug}' must include non-empty tasks")
                    continue
                task_ids: list[str] = []
                seen_tasks = set()
                for t_idx, t in enumerate(tasks):
                    if not isinstance(t, dict):
                        err(
                            f"task-order.yaml: feature '{slug}' task[{t_idx}] must be a map"
                        )
                        continue
                    tid = t.get("id")
                    if not isinstance(tid, str) or not ID_RE.match(tid):
                        err(
                            f"task-order.yaml: feature '{slug}' task[{t_idx}].id must be numeric string"
                        )
                        continue
                    if tid in seen_tasks:
                        err(
                            f"task-order.yaml: feature '{slug}' has duplicate task id '{tid}'"
                        )
                        continue
                    seen_tasks.add(tid)
                    task_ids.append(tid)
                    tpath = specs_dir / f"feature-{slug}-task-{tid}.md"
                    if not tpath.exists():
                        err(f"Missing task file: {tpath}")
                expected_tasks[slug] = task_ids
    elif task_order is not None:
        err("task-order.yaml: root must be a map")

    if isinstance(test_order, dict):
        features = test_order.get("features")
        if not isinstance(features, list) or not features:
            err("test-order.yaml: 'features' must be a non-empty list")
        else:
            for idx, f in enumerate(features):
                if not isinstance(f, dict):
                    err(f"test-order.yaml: feature[{idx}] must be a map")
                    continue
                slug = f.get("slug")
                if not isinstance(slug, str) or not slug:
                    err(f"test-order.yaml: feature[{idx}].slug must be a string")
                    continue
                if expected_tasks and slug not in expected_tasks:
                    err(f"test-order.yaml: unknown feature slug '{slug}'")
                    continue
                tasks = f.get("tasks")
                if not isinstance(tasks, list) or not tasks:
                    err(f"test-order.yaml: feature '{slug}' must include non-empty tasks")
                    continue
                for t_idx, t in enumerate(tasks):
                    if not isinstance(t, dict):
                        err(
                            f"test-order.yaml: feature '{slug}' task[{t_idx}] must be a map"
                        )
                        continue
                    tid = t.get("id")
                    if not isinstance(tid, str) or not ID_RE.match(tid):
                        err(
                            f"test-order.yaml: feature '{slug}' task[{t_idx}].id must be numeric string"
                        )
                        continue
                    if expected_tasks and tid not in expected_tasks.get(slug, []):
                        err(
                            f"test-order.yaml: feature '{slug}' references unknown task id '{tid}'"
                        )
                    tests = t.get("tests")
                    if not isinstance(tests, list) or not tests:
                        warn(
                            f"test-order.yaml: feature '{slug}' task '{tid}' has no tests"
                        )
                        continue
                    seen_tests = set()
                    for te_idx, te in enumerate(tests):
                        if not isinstance(te, dict):
                            err(
                                f"test-order.yaml: feature '{slug}' task '{tid}' test[{te_idx}] must be a map"
                            )
                            continue
                        teid = te.get("id")
                        if not isinstance(teid, str) or not ID_RE.match(teid):
                            err(
                                f"test-order.yaml: feature '{slug}' task '{tid}' test[{te_idx}].id must be numeric string"
                            )
                            continue
                        if teid in seen_tests:
                            err(
                                f"test-order.yaml: feature '{slug}' task '{tid}' has duplicate test id '{teid}'"
                            )
                            continue
                        seen_tests.add(teid)
                        tepath = specs_dir / f"feature-{slug}-task-{tid}-test-{teid}.md"
                        if not tepath.exists():
                            err(f"Missing test file: {tepath}")
    elif test_order is not None:
        err("test-order.yaml: root must be a map")

    if warnings:
        print("WARNINGS:", file=sys.stderr)
        for w in warnings:
            print(f"- {w}", file=sys.stderr)

    if errors:
        print("VALIDATION_FAILED", file=sys.stderr)
        for e in errors:
            print(f"- {e}", file=sys.stderr)
        return 1

    print("VALIDATION_OK")
    print(f"Features: {feature_slugs}")
    print(f"Tasks: {expected_tasks}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
